Γεώργιος Μάνος -  Α.Μ.: 4333

Η υλοποίηση μου είναι πάνω κάτω ως εξής:

Αρχικά, με την χρήση της readline (της βιβλιοθήκης, η οποία είδα ότι υπάρχει στον QEMU και 
είναι προσαρμοσμένη για τέτοιο σκοπό καθώς έχει και history και με την χρήση του tab κάνει
autocomplete το όνομα ενός αρχείου) τυπώνω το όνομα χρήστη και το path όπως γίνεται σε ένα 
shell ενώ περιμένω να διαβάσω την εντολή του χρήστη. Στην συνέχεια η είσοδος του χρήστη 
επεξεργάζεται από το πρόγραμμα, όπου κόβονται τα περιττά κενά ή προσθέτονται κατάλληλα.

Κατά την επεξεργασία αυτήν, η είσοδος αποθηκεύεται σε έναν global buffer (ολόκληρη), ωστόσο
εάν εντοπιστεί κάποιο pipe "|" ή κάποιο semi-colon ";" επιστρέφεται μόνο η πρώτη εντολή, και
αλλάζει ταυτόχρονα το state του διαβάσματος, περιμένοντας να ξανακληθεί η συνάρτηση get_formatted_line
μέχρι να διαβαστεί ο χαρακτήρας αλλαγής γραμμής ή EOF. Κατά αυτόν τον τρόπο μπορούμε να εκτελέσουμε την
πρώτη εντολή πριν καν διαβάσουμε την 2η, ενώ ταυτόχρονα έχουμε καλύτερο διαχωρισμό των εντολών.
Στην συνέχεια η εντολή εισόδου σπάει σε tokens ανά κενό πριν κινηθεί προς εκτέλεση. Εάν εντοπιστούν
pipes δημιουργείται μια λίστα που περιέχει τις εντολές αυτές, και στην συνέχεια η λίστα αυτή περνάει
στην κατάλληλη συνάρτηση, όπου για τις Ν εντολές δημιουργούνται Ν-1 pipes ώστε να επικοινωνούν μεταξύ
τους, και όλες εκτός από την πρώτη διαβάζουν από το file descriptor που έγραψε η προηγούμενη τους, και
όλες εκτός από την τελευταία γράφουν το αποτέλεσμα τους στην 2η θέση του filedescriptor από όπου θα διαβάσει
η επόμενη εντολή.

Fork κάνουμε πριν την εκτέλεση κάποιας εντολής ώστε εάν τερματίσει η διεργασία να μην επηρεάσει τις υπόλοιπες
(εκτός εάν υπάρχει κάποιο pipe προφανώς). Το πρόγραμμα μου έτρεξε άψογα και στο pc μου και στον QEMU, ο οποίος
ειλικρινά είναι αρκετά δύσχρηστος και κουραστικός. Παρ'όλα αυτά δεν είχα κάποιο fork bomb ούτε κάποιο crash στο
pc μου, ενώ τα memory leaks είναι λίγα αλλά υπαρκτά (κυρίως strings).